{"meta":{"title":"AndyMo's Blog","subtitle":"AndyMo's Blog","description":"AndyMo's Blog","author":"AndyMo","url":"andymo.top","root":"/"},"pages":[{"title":"About AndyMo","date":"2019-08-23T12:10:36.000Z","updated":"2019-10-26T11:19:54.574Z","comments":true,"path":"about/index.html","permalink":"andymo.top/about/index.html","excerpt":"","text":"oier 坐标广东 只会一点c++ oi水平不高，大概是文化课选手，打div3都掉分的那种 不太合格的 loveliver、μ’ser、鸟厨 现高一 (・8・) μ’s时光蛋"},{"title":"tags","date":"2019-10-26T09:43:39.000Z","updated":"2019-10-26T09:48:14.142Z","comments":true,"path":"tags/index.html","permalink":"andymo.top/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-08-23T10:42:14.000Z","updated":"2019-10-26T09:44:44.303Z","comments":true,"path":"categories/index.html","permalink":"andymo.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Luogu P5018 对称二叉树","slug":"Luogu P5018 对称二叉树","date":"2019-10-26T09:35:38.000Z","updated":"2019-10-26T10:48:05.700Z","comments":true,"path":"2019/10/26/Luogu P5018 对称二叉树/","link":"","permalink":"andymo.top/2019/10/26/Luogu P5018 对称二叉树/","excerpt":"","text":"搜索​ 如果一个二叉树是对称的，那么对于深度相同的两个节点$u$,$v$，必定有$lson(u)$与$rson(v)$，$rson(u)$与$lson(v)$，并且$val_u==val_v$ 每次搜深度相同的两个点（反正那时候noip想不出） 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 1000005int n;int val[N],son[N][2],size[N];void dfs(int u)&#123; size[u]=1; if(son[u][0]!=-1)&#123; dfs(son[u][0]); size[u]+=size[son[u][0]]; &#125; if(son[u][1]!=-1)&#123; dfs(son[u][1]); size[u]+=size[son[u][1]]; &#125;&#125;bool check(int u,int v)&#123; if(u==-1&amp;&amp;v==-1) return 1; if(u!=-1&amp;&amp;v!=-1) return val[u]==val[v]&amp;&amp;check(son[u][0],son[v][1])&amp;&amp;check(son[u][1],son[v][0]); return 0;&#125;int main()&#123; read(n); for(re int i=1;i&lt;=n;i++) read(val[i]); for(re int i=1;i&lt;=n;i++) in2(son[i][0],son[i][1]); dfs(1); int ans=0; for(re int i=1;i&lt;=n;i++)&#123; if(check(son[i][0],son[i][1])) ans=max(ans,size[i]); &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"andymo.top/tags/搜索/"}]},{"title":"51nod 1761相似关系","slug":"51nod 1761相似关系","date":"2019-10-26T09:34:33.000Z","updated":"2019-10-26T09:46:16.870Z","comments":true,"path":"2019/10/26/51nod 1761相似关系/","link":"","permalink":"andymo.top/2019/10/26/51nod 1761相似关系/","excerpt":"","text":"乱hash 题意：如果两个人各自认识的所有人或不认识的所有人完全一样（两个人是不是认识不计入答案），答案++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 1000005#define ull unsigned long longint n,m;struct node&#123; int id; ull v;&#125;a[N];bool cmp(node a,node b)&#123; return a.v&lt;b.v;&#125;int main()&#123; int x,y; in2(n,m); for(re int i=1;i&lt;=n;i++) a[i].id=i; for(re int i=1;i&lt;=m;i++) in2(x,y),a[x].v+=1ull*y*y*y,a[y].v+=1ull*x*x*x; sort(a+1,a+n+1,cmp); int cnt=0; ll ans=0; for(re int i=1;i&lt;=n;i++)&#123; if(a[i-1].v!=a[i].v) cnt=0; cnt++; ans+=cnt-1; &#125; for(re int i=1;i&lt;=n;i++) a[i].v+=1ull*a[i].id*a[i].id*a[i].id; sort(a+1,a+n+1,cmp); for(re int i=1;i&lt;=n;i++)&#123; if(a[i-1].v!=a[i].v) cnt=0; cnt++; ans+=cnt-1; &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"Hash","slug":"Hash","permalink":"andymo.top/tags/Hash/"}]},{"title":"Luogu P1365 WJMZBMR打osu! Easy","slug":"Luogu P1365 WJMZBMR打osu! Easy","date":"2019-10-26T09:31:07.000Z","updated":"2019-10-26T09:56:22.657Z","comments":true,"path":"2019/10/26/Luogu P1365 WJMZBMR打osu! Easy/","link":"","permalink":"andymo.top/2019/10/26/Luogu P1365 WJMZBMR打osu! Easy/","excerpt":"","text":"期望dp 本题期望combo为oo的期望连续长度的平方，所以我们设$f[i]$表示到了第$i$位的总期望combo，$g[i]$表示到了第$i$位结尾的连续oo的期望长度，那么分情况讨论： 1、当$s[i]==x$，则$f[i]=f[i-1],g[i]=0$ 2、当$s[i]==o$，则$f[i]=f[i-1]+2g[i-1]+1,g[i]=g[i-1]+1$$f[i]=(g[i-1]+1)^2=g[i-1]^2+2g[i-1]+1,g[i-1]^2=f[i-1]$ 3、当$s[i]==?$，则$f[i]=f[i-1]+g[i-1]+0.5,g[i]=\\frac{g[i-1]+1}{2}$ 滚动数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;int n;double f[2],g[2];int main()&#123; char ch; read(n); int cur=1; for(re int i=1;i&lt;=n;i++)&#123; scanf(\" %c\",&amp;ch); if(ch=='o') g[cur]=g[cur^1]+1,f[cur]=f[cur^1]+2*g[cur^1]+1; else if(ch=='x') f[cur]=f[cur^1],g[cur]=0; else g[cur]=(g[cur^1]+1)/2,f[cur]=f[cur^1]+g[cur^1]+0.5 //f[cur]=(f[cur-1]+(f[cur-1]+2*g[i-1]+1))/2; cur^=1; &#125; printf(\"%.4lf\",f[n&amp;1]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"期望","slug":"期望","permalink":"andymo.top/tags/期望/"}]},{"title":"51nod 2372 回文串统计","slug":"51nod 2372 回文串统计","date":"2019-10-26T09:26:04.000Z","updated":"2019-10-26T09:49:34.275Z","comments":true,"path":"2019/10/26/51nod 2372 回文串统计/","link":"","permalink":"andymo.top/2019/10/26/51nod 2372 回文串统计/","excerpt":"","text":"字符串 考虑如何快速找出拥有（与它的前缀相同的）后缀的串。这个东西可以通过把字符串放到Trie里面，或者利用map来解决。 分类两种情况，短串+长串和长串+短串。对于短串接在长串后面的情况，先将字符串按len从小到大排序，然后将字符串倒着插入trie里面，并在trie中的尾节点记录hash。利用当前串作为查询串来找答案，这样能保证当前串一定是长串，并且找到的所有短串都有和它的前缀相同的后缀，应为中间的串不知道是不是回文，所以再利用hash判断一下就可以确定拼出来的是不是回文串了。另外一个情况同理。 复杂度是$O(26∑len)$。用map的话做法本质是类似的，但是空间更小，不过复杂度带了个log By henry_y 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 100005#define base 233#define ull unsigned long longint n,len,tot;char t[N],s[N];ull power[N],h[N],g[N];int l[N],r[N],c[N][26],flag[N],cnt[N],pos[N];bool cmp(int a,int b)&#123; return r[a]-l[a]&lt;r[b]-l[b];&#125;ull calh(int l,int r)&#123; return h[r]-h[l-1]*power[r-l+1];&#125;ull calg(int l,int r)&#123; return g[l]-g[r+1]*power[r-l+1];&#125;bool check(int x,int y)&#123; ull A=calh(l[x],r[x])*power[r[y]-l[y]+1]+calh(l[y],r[y]); ull B=calg(l[y],r[y])*power[r[x]-l[x]+1]+calg(l[x],r[x]); return A==B;&#125;il void insert1(int i)&#123; int p=0; for(re int j=r[i];j&gt;=l[i];j--)&#123; int to=s[j]-'a'; if(!c[p][to]) c[p][to]=++tot; p=c[p][to]; &#125; flag[p]=i,cnt[p]++;&#125;il void insert2(int i)&#123; int p=0; for(re int j=l[i];j&lt;=r[i];j++)&#123; int to=s[j]-'a'; if(!c[p][to]) c[p][to]=++tot; p=c[p][to]; &#125; flag[p]=i,cnt[p]++;&#125;int main()&#123; ll ans=0; read(n); for(re int i=1;i&lt;=n;i++)&#123; scanf(\"%s\",t+1); int lt=strlen(t+1); for(re int j=1;j&lt;=lt;j++) s[j+len]=t[j]; l[i]=len+1; len+=lt; r[i]=len; pos[i]=i; &#125; power[0]=1; for(re int i=1;i&lt;=len;i++) h[i]=h[i-1]*base+s[i],power[i]=power[i-1]*base; for(re int i=len;i&gt;=1;i--) g[i]=g[i+1]*base+s[i]; sort(pos+1,pos+n+1,cmp); for(re int p=1;p&lt;=n;p++)&#123; int i=pos[p],u=0; for(re int j=l[i];j&lt;=r[i];j++)&#123; int to=s[j]-'a'; if(!c[u][to]) break; if(flag[u]&amp;&amp;check(i,flag[u])) ans+=cnt[u]; u=c[u][to]; &#125; if(flag[u]&amp;&amp;check(i,flag[u])) ans+=cnt[u]; insert1(i); &#125; memset(c,0,sizeof(c)); memset(flag,0,sizeof(flag)); memset(cnt,0,sizeof(cnt)); tot=0; for(re int p=1;p&lt;=n;p++)&#123; int i=pos[p],u=0; for(re int j=r[i];j&gt;=l[i];j--)&#123; int to=s[j]-'a'; if(!c[u][to]) break; if(flag[u]&amp;&amp;check(flag[u],i)) ans+=cnt[u]; u=c[u][to]; &#125; if(flag[u]&amp;&amp;check(flag[u],i)) ans+=cnt[u]; insert2(i); &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"andymo.top/tags/字符串/"}]},{"title":"Luogu  U85950 坐标编号","slug":"Luogu U85950 坐标编号","date":"2019-10-26T09:24:40.000Z","updated":"2019-10-26T10:49:27.461Z","comments":true,"path":"2019/10/26/Luogu U85950 坐标编号/","link":"","permalink":"andymo.top/2019/10/26/Luogu U85950 坐标编号/","excerpt":"","text":"数论+二分 编号公式：$(x+y)*(x+y-1)/2-y+1$ 将$(x+y-1)$拿去二分，设$mid=(x+y-1)$,判断$mid(mid+1)/2$和f的大小关系，如果$mid(mid+1)/2&gt;=f$ 则有可能为正确答案，因为$(x+y)(x+y-1)/2=f+y-1$,所以$(x+y)(x+y-1)/2&gt;=f$ 之后可以根据公式推出答案(二分上界不清楚) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define ull unsigned long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 100005ull f1,f2,x1,y1,x2,y2;void solve1()&#123; ull l=1,r=5e9,ans; while(l&lt;=r)&#123; ull mid=(l+r)&gt;&gt;1ull; if(mid*(mid+1)/2ull&gt;=f1) r=mid-1,ans=mid; else l=mid+1; &#125; y1=ans*(ans+1)/2ull+1-f1; x1=ans-y1+1;&#125;void solve2()&#123; ull l=1,r=5e9,ans; while(l&lt;=r)&#123; ull mid=(l+r)&gt;&gt;1ull; if(mid*(mid+1)/2ull&gt;=f2) r=mid-1,ans=mid; else l=mid+1; &#125; y2=ans*(ans+1)/2ull+1-f2; x2=ans-y2+1;&#125;int main()&#123; scanf(\"%lld %lld\",&amp;f1,&amp;f2); solve1(); solve2(); ull x=x1+x2; ull y=y1+y2; ull ans=(x+y)*(x+y-1)/2ull-y+1; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"数论","slug":"数论","permalink":"andymo.top/tags/数论/"},{"name":"二分","slug":"二分","permalink":"andymo.top/tags/二分/"}]},{"title":"Luogu P1823 [COI2007] Patrik 音乐会的等待","slug":"Luogu P1823 [COI2007] Patrik 音乐会的等待","date":"2019-10-26T09:23:29.000Z","updated":"2019-10-26T09:57:20.640Z","comments":true,"path":"2019/10/26/Luogu P1823 [COI2007] Patrik 音乐会的等待/","link":"","permalink":"andymo.top/2019/10/26/Luogu P1823 [COI2007] Patrik 音乐会的等待/","excerpt":"","text":"单调栈 栈顶高度最小，弹出小于等于当前高度的，答案加上当前高度的数量，并统计高度相同的数量。弹出后如果栈非空，答案加一。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 500005int n,top;struct node&#123; int h,cnt;&#125;a[N],st[N];int main()&#123; //freopen(\"data.in\",\"r\",stdin); read(n); ll ans=0; for(re int i=1;i&lt;=n;i++)&#123; read(a[i].h); a[i].cnt=1; while(top&amp;&amp;st[top].h&lt;=a[i].h)&#123; ans+=st[top].cnt; if(st[top].h==a[i].h) a[i].cnt+=st[top].cnt; top--; &#125; if(top) ans++; st[++top]=a[i]; &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"andymo.top/tags/单调栈/"}]},{"title":"51nod 2653 区间xor","slug":"51nod 2653 区间xor","date":"2019-10-26T09:20:48.000Z","updated":"2019-10-26T09:51:25.342Z","comments":true,"path":"2019/10/26/51nod 2653 区间xor/","link":"","permalink":"andymo.top/2019/10/26/51nod 2653 区间xor/","excerpt":"","text":"由于a,b范围10^9，暴力是不行的。考虑xor的特性，设 F(n) = 0 xor 1 xor 2 … xor n 存在：a xor (a+1) xor (a+2)…..xor b = F(b) xor F(a-1) 如何快速计算呢？我们考虑， 0 xor 1 = 1,2 xor 3 = 1,4 xor 5 = 1… 所以如果为偶数，存在， F(n) = 0(n % 4 = 0), F(n) = 1(n % 4 != 0) 如果为奇数， F(n) = F(n-1) xor n 。问题又转为了偶数的情况。 判断是奇数还是偶数时n要+1，因为得把0算进去 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;int a,b;int f(int n)&#123; if((n+1)%2) return f(n-1) xor n; else if((n+1)%4) return 1; else return 0;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif in2(a,b); printf(\"%d\",f(b) xor f(a-1)); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"数论","slug":"数论","permalink":"andymo.top/tags/数论/"}]},{"title":"Luogu P2990 [USACO10OPEN]牛跳房子Cow Hopscotch","slug":"Luogu P2990 [USACO10OPEN]牛跳房子Cow Hopscotch","date":"2019-10-26T09:18:55.000Z","updated":"2019-10-26T10:46:15.888Z","comments":true,"path":"2019/10/26/Luogu P2990 [USACO10OPEN]牛跳房子Cow Hopscotch/","link":"","permalink":"andymo.top/2019/10/26/Luogu P2990 [USACO10OPEN]牛跳房子Cow Hopscotch/","excerpt":"","text":"题解链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 250233int n,k,head=1,tail;int v[N],pos[N];ll f[N],q[N],sum[N];int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif in2(n,k); n++; for(re int i=2;i&lt;=n;i++) read(v[i]),sum[i]=sum[i-1]+1ll*(v[i]&gt;0)*v[i]; for(re int i=2,j=0;i&lt;=n;i++,j++)&#123; ll tmp=f[j]-sum[j];//对这个式子单调队列 while(head&lt;=tail&amp;&amp;q[tail]&lt;=tmp) tail--;//找回去的路上的最大值 q[++tail]=tmp; pos[tail]=j; while(head&lt;tail&amp;&amp;pos[head]&lt;i-k) head++; f[i]=q[head]+sum[i-2]+v[i-1]+v[i]; &#125; ll ans=f[1]+sum[min(1+k,n)]; for(re int i=2;i&lt;=n;i++)&#123; if(i+k-1&lt;=n) f[i]+=sum[i+k-1]-sum[i]; else f[i]+=sum[n]-sum[i]; ans=max(ans,f[i]); &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"},{"name":"单调队列","slug":"单调队列","permalink":"andymo.top/tags/单调队列/"}]},{"title":"初赛错题","slug":"初赛","date":"2019-10-26T09:16:29.000Z","updated":"2019-10-26T09:17:19.156Z","comments":true,"path":"2019/10/26/初赛/","link":"","permalink":"andymo.top/2019/10/26/初赛/","excerpt":"","text":"寄存器是（ ）的重要组成部分。 A. 硬盘 B. 高速缓存 C. 内存 D. 中央处理器（CPU） D 在使用高级语言编写程序时，一般提到的“空间复杂度”中的空间是指（ ）。 A. 程序运行时理论上所占的内存空间 B. 程序运行时理论上所占的数组空间 C. 程序运行时理论上所占的硬盘空间 D. 程序源文件理论上所占的硬盘空间 A 空间复杂度是对一个算法在运行过程中临时占用内存空间大小的量度。 应用快速排序的分治思想，可以实现一个求第K大数的程序。假定不考虑极端的最坏情况，理论上可以实现的最低的算法时间复杂度为（ ）。 A. O (n2) B. O (n log n ) C. O (n) D. O (1) C 为解决web应用中的不兼容问题，保障信息的顺利流通，（ ）制定了一系列标准，涉及HTML、XML、CSS等，并建议开发者遵循。 A. 微软 B. 美国计算机协会（ACM） C. 联合国教科文组织 D. 万维网联盟（W3C） D 1956年（ ）授予肖克利（William Shockley）、巴丁（John Bardeen）和布拉顿（Walter Brattain） A. 诺贝尔物理学奖 B. 约翰·冯·诺依曼奖 C. 图灵奖 D. 高德纳奖 （Donald E. Knuth Prize） A 字符“A”的ASCII码为十六进制41，则字符“Z”的ASCII码为十六进制的（ ）。 A. 66 B. 5A C. 50 D. 视具体的计算机而定 B 4*16+1=65 65+25=90 90/16=5…10=A 5/16=0..5 5A 应用快速排序的分治思想，可以实现一个求第K大数的程序。假定不考虑极端的最坏情况，理论上可以实现的最低的算法时间复杂度为（ ）。 A. O (n2) B. O (n log n ) C. O (n) D. O (1) C 二叉树k个节点，最小深度= $floor(log(k))$ 2^k-1&gt;=2011 2012&lt;=2^k k&gt;=floor(log(2012))=11 汇编语言（ ）。 A. 是一种与具体硬件无关的程序设计语言 B. 在编写复杂程序时，相对于高级语言而言代码量大，且不易调试 C. 可以直接访问寄存器、内存单元、I/O端口 D. 随着高级语言的诞生，如今已被完全淘汰，不再使用 正确答案： BC 对于序列“7、5、1、9、3、6、8、4”，在不改变顺序的情况下，去掉（ ）会使逆序对的个数减少3。 A. 7 B. 5 C. 3 D. 6 正确答案： CD 7 3;5 3;9 3 7 6;9 6;6 4 计算机中的数值信息分为整数和实数（浮点数）。实数之所以能够表示很大或者很小的数，是由于使用了（ ）。 A. 阶码 B. 补码 C. 反码 D. 较长的尾数 正确答案： A 现有一段文言文，要通过二进制哈夫曼编码进行压缩。简单起见，假设这段文言文只由4个汉字“之”、“乎”、“者”、“也”组成，它们出现的次数分别为700、600、300、400。那么，“也”字的编码长度可能是（ ）。 A. 1 B. 2 C. 3 D. 4 正确答案： BC 每次选最小的两个节点，新建一个节点连起来，构造一棵树，每个节点连向左右子树的两条边赋上不同边权，点到根节点的距离就是编码长度 构造出来两棵树，但总的编码长度相同 为计算机网络中进行数据交换而建立的规则、标准或约定的集合称为网络协议。下列英文缩写中，（ ）是网络协议。 A. HTTP B. TCP/IP C. FTP D. WWW 正确答案： ABC 平面图可以在画在平面上，且它的边仅在顶点上才能相交的简单无向图。4个顶点的平面图至少有6条边，如下图所示。那么，5个顶点的平面图至少有_条边。 正确答案： 9 在4个区域中加新节点，连边，不和其他边相交，最多连三条 如果根结点的深度记为1，则一棵恰有2011个叶子结点的二叉树的深度可能是（ ）。 A. 10 B. 11 C. 12 D. 2011 正确答案： CD 2^(k-1)&gt;=2011 k&gt;=12 前边可以有很长的链，再接上深度为12的那一部分二叉树 Linux下可执行文件的默认扩展名是( )。 A. exe B. com C. dll D. 以上都不是 正确答案： D 如果在某个进制下等式$77=41$成立，那么在该进制下等式$1212=$（ ）也成立。 A. 100 B. 144 C. 164 D. 196 正确答案： B $4*12+1=49$ $7 * 7= 49$ 说明为12进制 $12/12=1…0$ $1/12=0…1$ 12十进制下为10 $10*10=100$ $1 12 12+0 12+0 1=144$ 完全二叉树的顺序存储方案，是指将完全二叉树的结点从上到下、从左到右依次存放到一个顺序结构的数组中。假定根结点存放在数组的1号位置上，则第k号结点的父结点如果存在的话，应当存放在数组中的（ ）号位置。 A. 2k B. 2k+1 C. k/2下取整 D. (k+1)/2 正确答案： C Pascal语言，C语言和C++语言都属于( )。 A. 高级语言 B. 自然语言 C. 解释性语言 D. 编译性语言 正确答案： AD 原地排序是指在排序过程中(除了存储待排序元素以外的)辅助空间的大小与数据规模无关的排序算法。以下属于原地排序的有( )。 A. 冒泡排序 B. 插入排序 C. 基数排序 D. 选择排序 正确答案： ABD 在整数的补码表示法中，以下说法正确的是（ ）。 A. 只有负整数的编码最高位为1 B. 在编码的位数确定后，所能表示的最小整数和最大整数的绝对值相同 C. 整数0只有一个唯一的编码 D. 两个用补码表示的数相加时，如果在最高位产生进位，则表示运算溢出 正确答案： AC 补码特点|minint| = |maxint| + 1 在下列HTML语句中，可以正确产生一个指向NOI官方网站的超链接的是（ ）。 A. 欢迎访问NOI网站 B. 欢迎访问NOI网站 C. http://www.noi.cn D. 欢迎访问NOI网站 正确答案： B 关于拓扑排序，下列说法正确的是( )。 A. 所有连通的有向图都可以实现拓扑排序 B. 对同一个图而言，拓扑排序的结构是唯一的 C. 拓扑排序中入度为0的结点总会排在入度大于0的结点的前面 D. 拓扑排序结果序列中的第一个结点一定是入度等于0的点 正确答案： D 无论是 TCP/IP 模型还是 OSI 模型，都可以视为网络的分层模型，每个网络协议都会被归入某一层中。如果用现实生活中的例子来比喻这些“层”，以下最恰当的是（ ）。 A. 中国公司的经理与缅甸公司的经理交互商业文件 B. 军队发布命令 C. 国际会议中，每个人都与他国地位对等的人直接进行会谈 D. 体育比赛中，每一级比赛的优胜者晋级上一级比赛 正确答案： A 以下不属于目前 3G（第三代移动通信技术）标准的是（）。 A. GSM B. TD-SCDMA C. CDMA2000 D. WCDMA 正确答案： A 一棵二叉树一共有 19 个节点，其叶子节点可能有（ ）个。 A. 1 B. 9 C. 10 D. 11 正确答案： ABC 记n0为叶子节点的数量，n1为只有一个孩子的节点的数量，n2为有两个孩子的节点的数量有如下性质 n0=n2+1n0+n1+n2=19 2n0-1+n1=19 2n0+n1=20 且n0,n1,n2&gt;=0,n0+n1+n2=19 所以n0&lt;=10 已知一棵二叉树有 2013 个节点，则其中至多有（ ）个节点有 2 个子节点。 A. 1006 B. 1007 C. 1023 D. 1024 正确答案： A n0+n1+n2=2013 2*$n2$+n1+1=2013 2*n2+n1=2012 n1&gt;=0 n2&lt;=1006 $2^{n + 1} = 2 \\times 2^n$ 2是常数，可以省略 T(n)表示某个算法输入规模为 n 时的运算次数。如果 T(1)为常数，且有递归式 T(n) = 2*T(n / 2) + 2n，那么 T(n) = （ ）。 A. Θ(n) B. Θ(n log n) C. Θ(n2) D. Θ(n2 log n) B T(n)=2T(n/2)+n =4T(n/4)+2*n/2+n =16(n/16)+4n/4+2n/2+n … =nT(1)+nlogn 一个 32 位整型变量占用（ ）个字节。 A. 4 B. 8 C. 32 D. 128 正确答案： A bool 1short 2int 4long long 8float 4double 8long double 16 1948 年，（ ）将热力学中的熵引入信息通信领域，标志着信息论研究的开端。 A. 冯·诺伊曼（John von Neumann） B. 图灵（Alan Turing） C. 欧拉（Leonhard Euler） D. 克劳德·香农（Claude Shannon） 正确答案： D 斐波那契数列的定义如下：F1 = 1, F2 = 1, Fn = Fn – 1 + Fn – 2 (n ≥ 3)。如果用下面的函数计 算斐波那契数列的第 n 项，则其时间复杂度为（ ）。 int F(int n){ if (n &lt;= 2) return 1; else return F(n - 1) + F(n - 2);} A. O(1) B. O(n) C. O(n2) D. O(Fn)正确答案： D 二叉查找树具有如下性质：每个节点的值都大于其左子树上所有节点的值、小于其右子 树上所有节点的值。那么，二叉查找树的（ ）是一个有序序列。 A. 先序遍历 B. 中序遍历 C. 后序遍历 D. 宽度优先遍历 正确答案： B IPv4 协议使用 32 位地址，随着其不断被分配，地址资源日趋枯竭。因此，它正逐渐被 使用（ ）位地址的 IPv6 协议所取代。 A. 40 B. 48 C. 64 D. 128 正确答案： D 二分图是指能将顶点划分成两个部分，每一部分内的顶点间没有边相连的简单无向图。 那么，12 个顶点的二分图至多有（ ）条边。 A. 18 B. 24 C. 36 D. 66 正确答案： C （ ）是一种通用的字符编码，它为世界上绝大部分语言设定了统一并且唯一的二进制编码，以满足跨语言、跨平台的文本交换。目前它已经收录了超过十万个不同字符。 A. ASCII B. Unicode C. GBK 2312 D. BIG5 正确答案： B 把 64 位非零浮点数强制转换成 32 位浮点数后，不可能（ ）。 A. 大于原数 B. 小于原数 C. 等于原数 D. 与原数符号相反 正确答案： D 对一个 n 个顶点、m 条边的带权有向简单图用 Dijkstra 算法计算单源最短路时，如果不使用堆或其它优先队列进行优化，则其时间复杂度为（ ）。 A. O(mn + n^3) B. O(n^2) C. O((m + n) log n) D. O((m + n^2) log n) 正确答案： B （ ）属于 NP 类问题。 A. 存在一个 P 类问题 B. 任何一个 P 类问题 C. 任何一个不属于 P 类的问题（不一定） D. 任何一个在（输入规模的）指数时间内能够解决的问题（不一定） 正确答案： AB P:有多项式时间复杂度的解法(n!不是多项式) NP:验证一个解所用的时间复杂度为多项式，不一定存在多项式时间复杂度的解法 P类问题是NP问题的子集，因为存在多项式时间解法的问题，总能在多项式时间内验证他。 CCF NOIP 复赛考试结束后，因（ ）提出的申诉将不会被受理。 A. 源程序文件名大小写错误 B. 源程序保存在指定文件夹以外的位置 C. 输出文件的文件名错误 D. 只提交了可执行文件，未提交源程序 正确答案： ABCD 斐波那契数列的定义如下：F1 = 1, F2 = 1, Fn = Fn – 1 + Fn – 2 (n ≥ 3)。如果用下面的函数计 算斐波那契数列的第 n 项，则其时间复杂度为（ ）。 int F(int n){ if (n &lt;= 2) return 1; else return F(n - 1) + F(n - 2);} A. O(1) B. O(n) C. O(n2) D. O(Fn) 正确答案： D 时间复杂度为指数级，大约要算f(n)次1 二分图是指能将顶点划分成两个部分，每一部分内的顶点间没有边相连的简单无向图。 那么，12 个顶点的二分图至多有（ ）条边。 A. 18 B. 24 C. 36 D. 66 正确答案： C 这道题一边 6 个 就 6*6=36 条边 考虑你把这个图划成两个部分：x 个黑点和 n-x 个白点，那么就可以连 x(n-x) 条边 x = 6 时最大 现有一只青蛙，初始时在 n 号荷叶上。当它某一时刻在 k 号荷叶上时，下一时刻将等概 率地随机跳到 1, 2, …, k 号荷叶之一上，直至跳到 1 号荷叶为止。当 n = 2 时，平均一共 跳 2 次；当 n = 3 时，平均一共跳 2.5 次。则当 n = 5 时，平均一共跳_次。 直接设 f[i] 表示 i 跳到 1 要多少次 f[1] = 0 f[2]=1/2 f[1] +1/2 f[2]+1 f[2]=2 f[3]=1/3 f[1] +1/3 f[2] +1/3 f[3]+1 f[3]=5/2 f[4]=1/4 f[1]+1/4 f[2]+1/4 f[3]+1/4f[4]+1 f[4]=17/6 f[5]=1/5 f[1]+1/5 f[2]+1/5 f[3]+1/5 f[4]+1/5 f[5]+1 f[5]=37/12 正确答案： 37/12 $f[u] = \\sum_{u -&gt; v} p[u]v$ 终点为f[t]=0，即可推出f[s] 123456789101112#include &lt;stdio.h&gt; int main() &#123; int a, b, u, v, i, num; scanf(\"%d%d%d%d\", &amp;a, &amp;b, &amp;u, &amp;v); num = 0; for (i = a; i &lt;= b; i++) if (((i % u) == 0) || ((i % v) == 0)) num++; printf(\"%d\\n\", num); return 0; &#125; 输入：1 1000 10 15 输出：_ 1000/10=100,1000/15=66,1000/lcm(10,15)=1000/30=33 100+66-33=133 以下哪个是面向对象的高级语言( ). A. 汇编语言 B. C++ C. FORTRAN D. Basic 正确答案： B 1TB代表的字节数量是( ). A. 2的10次方 B. 2的20次方 C. 2的30次方 D. 2的40次方 正确答案： D 1TB=1024 GB =1024 * 1024 MB =1024 1024 1024 KB =1024^4 B。 2B是一个字节 TCP协议属于哪一层协议( ). A. 应用层 B. 传输层 C. 网络层 D. 数据链路层 正确答案： B 在无向图中，所有定点的度数之和是边数的( )倍. A. 0.5 B. 1 C. 2 D. 4 正确答案： C 对长度位n的有序单链表，若检索每个元素的概率相等，则顺序检索到表中任一元素的平均检索长度为( ). A. n/2 B. (n+1)/2 C. (n-1)/2 D. n/4 正确答案： B 同时查找2n 个数中的最大值和最小值，最少比较次数为( ). A. 3(n-2)/2 B. 4n-2 C. 3n-2 D. 2n-2 正确答案： C 设G是有6个结点的完全图，要得到一颗生成树，需要从G中删去( )条边. A. 6 B. 9 C. 10 D. 15 正确答案： C n个端点的完全图有n个端点以及n(n − 1) / 2条边 生成树n个节点，n-1条边 下列( )软件属于操作系统软件。 A. Microsoft Word B. Windows XP C. Android D. Mac OS X E. Oracle 正确答案： BCD 二进制补码求和：11010010+00000101=( ) A. 11000011B. 10110110C. 11010111D. 10001001 直接加 C 6.在待排序文件已基本有序的前提下，下述排序方法中效率最高的是（ ）A. 插入排序B. 选择排序C. 快速排序D. 归并排序 A 以下不属于结构化程序的结构是（ ） A. 顺序结构B. 输入输出结构C. 分支结构D. 循环结构 B 在 个结点的顺序表中，算法的时间复杂度是 的操作是（ ）。A．访问第i个结点和求第i个结点的直接前驱B．在第i个结点后插入一个新结点C．删除第i个结点D．将n个结点从小到大排序 A 顺序表即数组 将2个红球，1个蓝球，1个白球放到10个编号不同的盒子中去，每个盒子最多放一个球。有多少种放法( ) A. 5040B. 2520C. 420D. 1260 B $1098*7/2$ 2个红球/2 下列网络设备中，不属于局域网设备的是（ ）A. 路由器B. 集线器C. 网卡D. 中继器 A 下列属于解释执行的程序设计语言是 A. C B. C++ C. Pascal D. Python 正确答案： D 中国计算机学会于（ ）年创办全国青少年计算机程序设计竞赛。 A. 1983 B. 1984 C. 1985 D. 1986 正确答案： B 根节点深度为 0，一棵深度为 h 的满 k（k&gt;1）叉树，即除最后一层无任何子 节点外，每一层上的所有结点都有 k 个子结点的树，共有（ ）个结点。 A$ (k^{h+1}-1)/(k-1)$ B.$ k^{h-1}$ C. $k^h$ D. $(k^{h-1})/(k-1)$ 正确答案： A 等比数列要除以(k-1) 满二叉树：$2^k-1(/(2-1))$ 设某算法的时间复杂度函数的递推方程是T(n) = T(n - 1) + n（n 为正整数）及T(0) = 1，则该算法的时间复杂度为（ ）。 A. O(log n) B. O(n log n) C. O(n) D. O(n^2) 正确答案： D 关于Catalan 数 Cn = (2n)! / (n + 1)! / n！，下列说法中错误的是（ ）。 A. Cn 表示有n + 1 个结点的不同形态的二叉树的个数。 B. Cn 表示含n 对括号的合法括号序列的个数。 C. Cn 表示长度为n 的入栈序列对应的合法出栈序列个数。 D. Cn 表示通过连接顶点而将n + 2 边的凸多边形分成三角形的方法个数。 正确答案： A 假设一台抽奖机中有红、蓝两色的球，任意时刻按下抽奖按钮，都会等概率获得红球或蓝球之一。有足够多的人每人都用这台抽奖机抽奖，假如他们的策略均为：抽中蓝球则继续抽球，抽中红球则停止。最后每个人都把自己获得的所有球放到一个大箱子里，最终大箱子里的红球与蓝球的比例接近于（ ）。 A. 1 : 2 B. 2 : 1 C. 1 : 3 D. 1 : 1 正确答案： D 设 $E(x)$ 表示抛掷硬币次数(抽球次数)的期望值 $E(x) = 1 + 1/2E(x)$ $=&gt; E(x) = 2$ 正面：$1$ 次 反面：$1 + E(x)$ 次 $E(x) = 1/2 1 + 1/2 (1 + E(x))$ $E(x) = 2$ 而红球只会抽1个，所以蓝球也为1个 设 $E(x)$ 表示期望的蓝球数 $E(x)=1/2 0 + 1/2 ( E(x) + 1 )$ $=&gt; E(x) = 1$ 在一条长度为 1 的线段上随机取两个点，则以这两个点为端点的线段的期望长度是（ ）。 A. 1 / 2 B. 1 / 3 C. 2 / 3 D. 3 / 5 正确答案： B //By Tsukimaru 下列关于最短路算法的说法正确的有（ ）。 A. 当图中不存在负权回路但是存在负权边时，Dijkstra 算法不一定能求出源点到所有点的最短路。 B. 当图中不存在负权边时，调用多次Dijkstra 算法能求出每对顶点间最短路径。 C. 图中存在负权回路时，调用一次Dijkstra 算法也一定能求出源点到所有点的最短路。 D. 当图中不存在负权边时，调用一次Dijkstra 算法不能用于每对顶点间最短路计算。 正确答案： A / B / D 有负权就有可能会出错 若某算法的计算时间表示为递推关系式：T(N) = 2T(N / 2) + N log NT(1) = 1则该算法的时间复杂度为（ ）。 A. O(N) B. O(N \\log N) C. O(N \\log^2 N) D. O(N^2) 正确答案： C //By Tsukimaru 分辨率为 1600x900、16 位色的位图，存储图像信息所需的空间为（ ）。 A. 2812.5KB B. 4218.75KB C. 4320KB D. 2880KB A 长 宽 位数（或者说色深）得出的是bit，除以8才能得出Byte（字节） 文件是以字节来计数而不是位（bit） 至于用多少种色彩来表示像素点，就决定了颜色的位数，比如256种颜色来表示，就是2的8次方，那么用8位来表示颜色就可以了。65536种颜色就是2的16此方，需要16位来表示某像素的颜色值。 从（ ）年开始，NOIP 竞赛将不再支持 Pascal 语言。 A. 2020 B. 2021 C. 2022 D. 2023 正确答案： C 将 7 个名额分给 4 个不同的班级，允许有的班级没有名额，有（ ）种不 同的分配方案。 A. 60 B. 84 C. 96 D. 120 正确答案： D 设$ f[i][j] 为前$ i $个班级，有$ j $个名额的方案数$ $f[i][j]=\\sum^{j}_{k=0}{f[i-1][j-k]}=f[i][j-1]+f[i-1][j]$ 列表递推 以下是面向对象的高级语言的有（ ）。 A. 汇编语言 B. C++ C. Fortran D. Java 正确答案： BD 以下和计算机领域密切相关的奖项有（ ）。 A. 奥斯卡奖 B. 图灵奖 C. 诺贝尔奖 D. 王选奖 正确答案： BD 9.某计算机的 CPU 和内存之间的地址总线宽度是 32 位（bit），这台计算机最多可以使用（ ）的内存。 A. 2GB B. 4GB C. 8GB D. 16GB 正确答案： B 2^32 Byte=2^22 Kb=2^12 Mb=2^2 Gb 地址总线的位数决定了CPU可直接寻址的内存空间大小，比如8位微机的地址总线为16位，则其最大可寻址空间为2^16=64KB，16位微型机的地址总线为20位，其可寻址空间为2^20=1MB。一般来说，若地址总线为n位，则可寻址空间为2^n位。 以下属于无线通信技术的有（ ）。 A. 蓝牙 B. WiFi C. GPRS D. 以太网 正确答案： ABC 可以将单个计算机接入到计算机网络中的网络接入通讯设备有（ ）。 A. 网卡 B. 光驱 C. 鼠标 D. 显卡 正确答案： A 下列算法中运用分治思想的有（ ）。 A. 快速排序 B. 归并排序 C. 冒泡排序 D. 计数排序 正确答案： AB 有 7 个一模一样的苹果，放到 3 个一样的盘子中，一共有（ ）种放法。 A. 7 B. 8 C. 21 D. 3^7 正确答案： B 暴力枚举 假设某算法的计算时间表示为递推关系式 T(n) = 2T(\\frac{N}{4})+sqrt(n)T(n)=2T(4N )+sqrt(n)T(1) = 1T(1)=1则算法的时间复杂度为（ ）。 A. $O(n)$ B. $O(\\sqrt{n})$ C. $O(\\sqrt{n}\\log{n})$ D. $O(n^2)$ 正确答案： C $T(n)=2T(n/4)+\\sqrt{n}$ $=4T(n/16)+\\sqrt{n}+\\sqrt{n}$ $=8T(n/64)+\\sqrt{n}+\\sqrt{n}+\\sqrt{n}$ $……$ $ =2^{\\log_4{n}}+\\sqrt{n}\\log_4{n}$ $ =2^{\\log_2{n}}+\\sqrt{n}\\log_2{n}$ $ =n+\\sqrt{n}\\log_2{n}$ $ =\\sqrt{n}\\log_2{n}$ 以下属于无线通信技术的有（ ）。 A. 蓝牙 B. WiFi C. GPRS D. 以太网 正确答案： ABC 下列算法中运用分治思想的有（ ）。 A. 快速排序 B. 归并排序 C. 冒泡排序 D. 计数排序 正确答案： AB 一个 1×8 的方格图形（不可旋转）用黑、白两种颜色填涂每个方格。如果每个方格只能填涂一种颜色，且不允许两个黑格相邻，共有_种填涂方案。 正确答案： 55 设$f[i][0/1]$为到第$i$个格子的方案数，0为白，1为黑$ $f[i][0]=f[i-1][0]+f[i-1][1]$ $f[i][1]=f[i-1][0]$ $Ans=max(f[8][0],f[8][1])$ 线性表若采用链表存储结构，要求内存中可用存储单元地址（ ）。 A. 必须连续 B. 部分地址必须连续 C. 一定不连续 D. 连续不连续均可 正确答案： D 下列说法正确的是（ ）。 A. CPU 的主要任务是执行数据运算和程序控制 B. 存储器具有记忆能力，其中信息任何时候都不会丢失 C. 两个显示器屏幕尺寸相同，则它们的分辨率必定相同 D. 个人用户只能使用 Wifi 的方式连接到 Internet 正确答案： A 前序遍历序列与后序遍历序列相同的二叉树为（ ）。 A. 非叶子结点只有左子树的二叉树 B. 只有根结点的二叉树 C. 根结点无右子树的二叉树 D. 非叶子结点只有右子树的二叉树 正确答案： B 前序遍历:根 左 右 后序遍历:左 右 根 说明既没有左子树也没有右子树 如果根的高度为 1，具有 61 个结点的完全二叉树的高度为（ ）。 A. 5 B. 6 C. 7 D. 8 正确答案： B 具有$n$个节点的二叉树的深度为$\\lfloor log_2{n} \\rfloor +1$ 具有 n 个顶点，e 条边的图采用邻接表存储结构，进行深度优先遍历和广度优先遍历运 算的时间复杂度均为（ ）。 A. Θ(n2) B. Θ(e2) C. Θ(ne) D. Θ(n + e) 正确答案： D 在数据压缩编码的应用中，哈夫曼（Huffman）算法是一种采用了（ ）思想的算法。 A. 贪心 B. 分治 C. 递推 D. 回溯 正确答案： A 以下图中一定可以进行黑白染色的有（ ）。（黑白染色：为各个结点分别指定黑白 两种颜色之一，使相邻结点颜色不同。） A. 二分图 B. 完全图 C. 树 D. 连通图 正确答案： AC 以下属于操作系统的有（ ）。 A. Windows XP B. UNIX C. Linux D. Mac OS 正确答案： ABCD 下列属于视频文件格式的有（ ）。 A. AVI B. MPEG C. WMV D. JPEG 正确答案： ABC 下列有关树的叙述中，叙述正确的有（ ）。 A. 在含有 n 个结点的树中，边数只能是(n-1)条 B. 在哈夫曼树中，叶结点的个数比非叶结点个数多 1 C. 完全二叉树一定是满二叉树 D. 在二叉树的前序序列中，若结点 u 在结点 v 之前，则 u 一定是 v 的祖先 正确答案： AB","categories":[],"tags":[{"name":"初赛","slug":"初赛","permalink":"andymo.top/tags/初赛/"}]},{"title":"Luogu P4954 [USACO09Open] Tower of Hay 干草塔","slug":"Luogu P4954 [USACO09Open] Tower of Hay 干草塔","date":"2019-10-26T09:13:16.000Z","updated":"2019-10-26T10:47:51.111Z","comments":true,"path":"2019/10/26/Luogu P4954 [USACO09Open] Tower of Hay 干草塔/","link":"","permalink":"andymo.top/2019/10/26/Luogu P4954 [USACO09Open] Tower of Hay 干草塔/","excerpt":"","text":"dp+单调队列 题解链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 100005int n;int a[N],sum[N],q[N],g[N],f[N];int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif read(n); for(re int i=n;i&gt;=1;i--) read(a[i]); for(re int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i]; int head=1,tail=0; for(re int i=1;i&lt;=n;i++)&#123; while(head&lt;=tail&amp;&amp;g[q[head]]+sum[q[head]]&lt;=sum[i]) head++;//找到最靠后且合法的一个，即为head-1 f[i]=f[q[head-1]]+1; g[i]=sum[i]-sum[q[head-1]]; while(head&lt;=tail&amp;&amp;g[q[tail]]+sum[q[tail]]&gt;=g[i]+sum[i]) tail--; q[++tail]=i; //printf(\"%d\\n\",f[i]); &#125; printf(\"%d\",f[n]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"},{"name":"单调队列","slug":"单调队列","permalink":"andymo.top/tags/单调队列/"}]},{"title":"Luogu U89680 连通性计数","slug":"Luogu U89680 连通性计数","date":"2019-10-26T09:12:28.000Z","updated":"2019-10-26T10:50:26.006Z","comments":true,"path":"2019/10/26/Luogu U89680 连通性计数/","link":"","permalink":"andymo.top/2019/10/26/Luogu U89680 连通性计数/","excerpt":"","text":"计数dp 我们用 $f_{i,j}$ 表示前 $i$ 个数，可以达到最大值为 $j$ 的方案数 转移时： 若前 $i - 1$ 个数已经能到达 $j$，则第 $i$ 个数可以选 $1$ 到 $j$ 里任意的数 否则前 $i - 1$ 个数必须能到达 $i$ 到 $j - 1$ 里的某个数，然后第 $i$ 个数设成 $j$ 因此，$f_{i,j} = f_{i-1,j} * j + \\sum_{k=i}^{j-1} f_{i-1,k}$ 利用滚动数组优化内存 通过预处理前缀和求区间和的方式，做到 $O(1)$ 转移 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 5005const int mod=1e9+7;int n;ll f[2][N],sum[N];int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif read(n); f[0][1]=sum[1]=1; for(re int i=1;i&lt;=n;i++) sum[i]+=sum[i-1]; int cur=1; for(re int i=1;i&lt;=n;i++)&#123; for(re int j=1;j&lt;=n;j++)&#123; f[cur][j]=(f[cur^1][j]*j)%mod; f[cur][j]=(f[cur][j]+sum[j-1]-sum[i-1]+mod)%mod; //printf(\"%d %d %lld %lld\\n\",i,j,f[i][j],sum[j]-sum[i-1]); &#125; for(re int j=1;j&lt;=n;j++) sum[j]=(sum[j-1]+f[cur][j])%mod; cur^=1; &#125; printf(\"%lld\",(f[n&amp;1][n]+mod)%mod); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"},{"name":"计数","slug":"计数","permalink":"andymo.top/tags/计数/"}]},{"title":"Luogu U88570 幸运摩天轮","slug":"Luogu U88570 幸运摩天轮","date":"2019-10-26T09:11:13.000Z","updated":"2019-10-26T10:49:48.611Z","comments":true,"path":"2019/10/26/Luogu U88570 幸运摩天轮/","link":"","permalink":"andymo.top/2019/10/26/Luogu U88570 幸运摩天轮/","excerpt":"","text":"贪心 考虑最差情况，将体重按照从小到大的顺序排序 然后将最小的满足 $a_{i} + a_{n} &gt; b$ 的配对，然后是最小的满足 $a_{i} + a_{n - 1} &gt; b$ 的配对，以此类推 将配好对的依次排在前面，将无法配对的按照体重从大到小跟在后面 再统计答案，此时为最差情况 应该把较小的放在较大的前面 最小的 最大的 次小的 次大的 最小的+最大的&gt;b 次小的+次大的&gt;b 所以最大的+次小的也&gt;b 最大的 最小的 次大的 次小的 最小的+次大的不一定&gt;b 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 105int n,b,cnt;int a[N],v[N];bool used[N];int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif in2(n,b); for(re int i=1;i&lt;=n;i++) read(a[i]); sort(a+1,a+n+1); int l=1,r=n; while(l&lt;r)&#123; while(l&lt;r&amp;&amp;a[l]+a[r]&lt;=b) l++; if(l&lt;r)&#123; used[l]=1; v[++cnt]=a[l++]; used[r]=1; v[++cnt]=a[r--]; &#125; &#125; if(l==r) used[l]=1,v[++cnt]=a[l]; for(re int i=1;i&lt;=n;i++) if(!used[i]) v[++cnt]=a[i]; int tmp=0,ans=0; for(re int i=1;i&lt;=n;i++)&#123; //printf(\"%d \",v[i]); if(tmp==0||tmp+v[i]&gt;b) ans++,tmp=v[i]; else tmp=0; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"andymo.top/tags/贪心/"}]},{"title":"Luogu P2458 [SDOI2006]保安站岗","slug":"Luogu P2458 [SDOI2006]保安站岗","date":"2019-10-26T09:08:34.000Z","updated":"2019-10-26T10:46:00.842Z","comments":true,"path":"2019/10/26/Luogu P2458 [SDOI2006]保安站岗/","link":"","permalink":"andymo.top/2019/10/26/Luogu P2458 [SDOI2006]保安站岗/","excerpt":"","text":"树形DP 控制的是点，不是边 设$f[u][0]$为被父亲控制，$f[u][1]$为被自己控制，$f[u][2]$为被儿子控制 $f[u][0]=∑min(f[v][1],f[v][2])$ $f[u][1]=∑min(f[v][0],f[v][1],f[v][2])+val[u]$ $f[u][2]=∑min(f[v][1],f[v][2]) + $某一个$f[v][1]$ (只要一个儿子被它自己控制就好) 叶子节点$f[u][2]=inf$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 1505int n,en;int front[N],w[N],f[N][3];struct edge&#123; int v,next;&#125;e[N&lt;&lt;1];il void add(int u,int v)&#123; en++; e[en].v=v; e[en].next=front[u]; front[u]=en;&#125;void dfs(int u,int fa)&#123; f[u][1]=w[u]; for(re int i=front[u];i;i=e[i].next)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u); f[u][0]+=min(f[v][1],f[v][2]); f[u][1]+=min(f[v][0],min(f[v][1],f[v][2])); &#125; f[u][2]=inf; for(re int i=front[u];i;i=e[i].next)&#123; int v=e[i].v; if(v==fa) continue; f[u][2]=min(f[u][2],f[u][0]-min(f[v][1],f[v][2])+f[v][1]); //将其中一个min(f[v][1],f[v][2])换成f[v][1] &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif int u,v,m; read(n); for(re int i=1;i&lt;=n;i++)&#123; read(u); read(w[u]); read(m); while(m--) read(v),add(u,v),add(v,u); &#125; dfs(1,1); printf(\"%d\",min(f[1][1],f[1][2]));//1不能被父亲控制 return 0;&#125; 123456789101112131415161718192021222324252627 定义：对于图G=(V,E)来说,最小支配集指的是从V中取尽量少的点组成 一个集合,使得对于V中剩余的点都与取出来的点有边相连.也就 是说,设V&apos;是图G的一个支配集,则对于图中的任意一个顶点u,要 么属于集合V&apos;,要么与V&apos;中的顶点相邻.在V&apos;中出去任何元素后V&apos; 不再是支配集,则支配集是极小支配集.称G的所有支配集中顶点 个数最少的支配集为最小支配集,最小支配集中顶点的个数称为 支配数。 对于任意图G来说,这个问题不存在多项式时间的解法。不过对于树来说,却很容易。 目前有两种解法,一种基于贪心思想,另一种基于树形动态规划思想。f(u,0):u点无人且未被儿子看守到的情况下,以u为根的子树的最优值 f(u,1):u点有人(即u点自己看守)的情况下,以u为根的子树的最优值 f(u,2):u点无人但被某子看守到的情况下,以u为根的子树的最优值 显然,若选1号结点为总根,则答案为min&#123; f(1,1) , f(1,2) &#125; 有以下状态转移方程：1) f(u,0) = f(v1,2) + f(v2,2) + ... + f(vm,2) , 当f(vi,2)皆不为INF即所有vi皆能被vi的子覆盖; INF , 当存在vi不能被子覆盖,即vi为叶子结点 2) f(u,1) = sum&#123; min&#123; f(v,0),f(v,1),f(v,2) &#125; &#125; + v[u]3) if (u无子) f(u,2) = INF else &#123; f(u,2) = sum&#123; min&#123; f(v,1),f(v,2) &#125; + C; 其中C: 若sum&#123; min&#123; f(v,1),f(v,2) &#125;有选到一个f(v,1)则C=0; 否则C= min&#123; f(v,1) - f(v,2) &#125; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"},{"name":"树形dp","slug":"树形dp","permalink":"andymo.top/tags/树形dp/"}]},{"title":"Luogu U89697 序列匹配","slug":"Luogu U89697 序列匹配","date":"2019-10-26T09:04:58.000Z","updated":"2019-10-26T10:51:16.408Z","comments":true,"path":"2019/10/26/Luogu U89697 序列匹配/","link":"","permalink":"andymo.top/2019/10/26/Luogu U89697 序列匹配/","excerpt":"","text":"模拟吧大概 自己hash瞎搞1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 200005#define mod 998244353const int base=2333333;int n,m;int s[N],t[N];map &lt;ll,ll&gt; mp;ll hash(ll x)&#123; ll val=x*x%mod*x%mod; ll tmp=x; while(mp[val]!=x&amp;&amp;mp[val]!=0) tmp++,val=(tmp*tmp%mod*tmp%mod)%mod; mp[val]=x; return val;&#125;int main()&#123; ll sta=0,val=0,ans=0; in2(n,m); for(re int i=1;i&lt;=n;i++)&#123; read(s[i]); if(i&lt;=m) val=(val+hash(s[i]))%mod; &#125; for(re int i=1;i&lt;=m;i++) read(t[i]),sta=(sta+hash(t[i]))%mod; for(re int i=1;i+m-1&lt;=n;i++)&#123; if(val==sta) ans+=1ll*i*i; val=(val-hash(s[i])+mod)%mod; val=(val+hash(s[i+m])%mod)%mod; &#125; printf(\"%lld\",ans); return 0;&#125; std的map 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 200005int n,m;int s[N],t[N];map &lt;int,int&gt; mp,cnt;int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif ll ans=0; in2(n,m); for(re int i=1;i&lt;=n;i++)&#123; read(s[i]); if(i&lt;=m) mp[s[i]]++; &#125; for(re int i=1;i&lt;=m;i++) read(t[i]),cnt[t[i]]++; int now=0; for(map&lt;int,int&gt;::iterator i=cnt.begin();i!=cnt.end();i++) if(mp[i-&gt;first]==i-&gt;second) now++;//(*i).first for(re int i=1;i+m-1&lt;=n;i++)&#123; if(now==cnt.size()) ans+=1ll*i*i; if(cnt.count(s[i])&amp;&amp;mp[s[i]]==cnt[s[i]]) now--; if(cnt.count(s[i])&amp;&amp;--mp[s[i]]==cnt[s[i]]) now++; if(cnt.count(s[i+m])&amp;&amp;mp[s[i+m]]==cnt[s[i+m]]) now--; if(cnt.count(s[i+m])&amp;&amp;++mp[s[i+m]]==cnt[s[i+m]]) now++; &#125; printf(\"%lld\",ans); return 0;&#125;另一种map​```cpp#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 200005int n,m;int s[N],t[N];map &lt;int,int&gt; cnt;int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif ll ans=0; in2(n,m); for(re int i=1;i&lt;=n;i++)&#123; read(s[i]); &#125; int now=0; for(re int i=1;i&lt;=m;i++)&#123; read(t[i]); if(cnt[t[i]]==0) now++; cnt[t[i]]++; &#125; for(re int i=1;i&lt;m;i++)&#123; if(cnt[s[i]]==0) now++; if(cnt[s[i]]==1) now--; cnt[s[i]]--; &#125; for(re int i=m;i&lt;=n;i++)&#123; if(cnt[s[i]]==0) now++; if(cnt[s[i]]==1) now--; cnt[s[i]]--; if(!now) ans+=1ll*(i-m+1)*(i-m+1); if(cnt[s[i-m+1]]==0) now++; if(cnt[s[i-m+1]]==-1) now--; cnt[s[i-m+1]]++; &#125; printf(\"%lld\",ans); return 0;&#125; cnt为t的元素的个数减去s的元素的个数","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"andymo.top/tags/字符串/"},{"name":"模拟","slug":"模拟","permalink":"andymo.top/tags/模拟/"}]},{"title":"Luogu U89699 俄罗斯套娃","slug":"Luogu U89699 俄罗斯套娃","date":"2019-10-26T09:03:02.000Z","updated":"2019-10-26T10:52:36.889Z","comments":true,"path":"2019/10/26/Luogu U89699 俄罗斯套娃/","link":"","permalink":"andymo.top/2019/10/26/Luogu U89699 俄罗斯套娃/","excerpt":"","text":"贪心 导弹拦截 按s升序排序，找最长不严格单调上升子序列（最长不下降子序列） 离散+树状数组（写死） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 200005int n,maxn;int num[N],c[N];struct node&#123; int s,t;&#125;a[N];void dec()&#123; for(re int i=1;i&lt;=n;i++) num[i]=a[i].s; sort(num+1,num+1+n); for(re int i=1;i&lt;=n;i++) a[i].s=lower_bound(num+1,num+n+1,a[i].s)-num; for(re int i=1;i&lt;=n;i++) num[i]=a[i].t; sort(num+1,num+1+n); for(re int i=1;i&lt;=n;i++) a[i].t=lower_bound(num+1,num+1+n,a[i].t)-num;&#125;bool cmp(node a,node b)&#123; if(a.s==b.s) return a.t&gt;b.t; return a.s&lt;b.s;&#125;il int query(int x)&#123; int res=0; for(re int i=x;i&gt;0;i-=i&amp;(-i)) res=max(res,c[i]); return res;&#125;il void add(int x,int val)&#123; for(re int i=x;i&lt;=maxn;i+=i&amp;(-i)) c[i]=max(c[i],val);&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif read(n); for(re int i=1;i&lt;=n;i++) in2(a[i].s,a[i].t); dec(); for(re int i=1;i&lt;=n;i++) maxn=max(maxn,a[i].t); sort(a+1,a+n+1,cmp); int ans=0; for(re int i=1;i&lt;=n;i++)&#123; //printf(\"%d %d \",a[i].s,a[i].t); int x=query(a[i].t)+1; //printf(\"%d\\n\",x); ans=max(ans,x); add(a[i].t,x); &#125; printf(\"%d\",ans); return 0;&#125; 小数据枚举嵌套关系，检查是否符合条件 中数据我们按照 $s_{i}$ 优先，其次 $t_{i}$ 对套娃进行排序 显然只有前面的套娃有可能套住后面的 如果前面有多个套娃可以套住当前套娃，显然在其中找 $t_{i}$ 较小的，防止浪费 而且如果当前套娃可以被套住，选择套住它一定是更优的（可以分类套路套与不套的情况 我们可以每次暴力扫描前面可用的套娃，选择合适的套住当前的 大数据上述做法的核心在于，如何选出最小的大于当前值 $t_{i}$ 使用 set 可以方便的实现上述需求 每个$t_{i}$不能立即加入集合，必须所有s相同的t一起加入集合，否则可能会继承$s_{i}$相同的$t_{i}$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;set&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 200005int n,maxn;struct node&#123; int s,t;&#125;a[N];multiset &lt;int&gt; st;bool cmp(node a,node b)&#123; if(a.s==b.s) return a.t&gt;b.t; return a.s&lt;b.s;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif read(n); for(re int i=1;i&lt;=n;i++) in2(a[i].s,a[i].t); sort(a+1,a+n+1,cmp); int j=1,ans=n; multiset &lt;int&gt; ::iterator it; for(re int i=1;i&lt;=n;i++)&#123; it=st.upper_bound(a[i].t); if(it!=st.end())&#123; st.erase(it); ans--; &#125; if(a[i].s^a[i+1].s)&#123; while(j&lt;=i)&#123; st.insert(a[j].t); j++; &#125; &#125; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"andymo.top/tags/贪心/"},{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"},{"name":"数据结构","slug":"数据结构","permalink":"andymo.top/tags/数据结构/"},{"name":"离散化","slug":"离散化","permalink":"andymo.top/tags/离散化/"}]},{"title":"CF109C Lucky Tree","slug":"CF109C Lucky Tree","date":"2019-10-26T08:59:46.000Z","updated":"2019-10-26T10:44:15.311Z","comments":true,"path":"2019/10/26/CF109C Lucky Tree/","link":"","permalink":"andymo.top/2019/10/26/CF109C Lucky Tree/","excerpt":"","text":"树形dp/计数 123456789101112131415解法一： f1(u):以u为根的子树中有多少个结点到u的路径中含幸运数f2(u):以u为根的子树外有多少个结点到u的路径中含幸运数cnt(u):以u为根的子树的结点数 显然有：1) 若边(u,vi)是幸运数,则f1(u) += cnt(vi) ,其中vi为u的子结点 否则,f1(u) += f1(vi) 2) 若边(u,vi)是幸运数,则f2(vi) = cnt(root)-cnt(vi),其中root为总根 否则,f2(vi) = f2(u) + f1(u)-f1(vi);f1(u)-f1(vi)即u其他子树中有多少个结点到u的路径中含幸运数ans(u):全图有多少个结点到u的路径中含幸运数。 按乘法原理,显然有: ans(u) = f1(u)*[f1(u)-1] + //两点皆在u子树内 f2(u)*[f2(u)-1] + //两点皆在u子树外 f1(u)*f2(u)*2 //内外各一点 总答案即为：sum( ans(ui) ) , ui=1,2,3,...,N 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 100005int n,en;int front[N],sum[N],f1[N],f2[N];ll ans;struct edge&#123; int v,w,next;&#125;e[N&lt;&lt;1];il void add(int u,int v,int w)&#123; en++; e[en].v=v; e[en].w=w; e[en].next=front[u]; front[u]=en;&#125;bool cal(int x)&#123; while(x)&#123; if(x%10!=4&amp;&amp;x%10!=7) return 0; x/=10; &#125; return 1;&#125;void dfs1(int u,int fa)&#123; sum[u]=1; for(re int i=front[u];i;i=e[i].next)&#123; int v=e[i].v,w=e[i].w; if(v==fa) continue; dfs1(v,u); sum[u]+=sum[v]; if(w) f1[u]+=sum[v]; else f1[u]+=f1[v]; &#125;&#125;void dfs2(int u,int fa)&#123; for(re int i=front[u];i;i=e[i].next)&#123; int v=e[i].v,w=e[i].w; if(v==fa) continue; if(w) f2[v]=sum[1]-sum[v]; else f2[v]=f1[u]+f2[u]-f1[v]; dfs2(v,u); &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif int u,v,w; read(n); for(re int i=1;i&lt;=n-1;i++) in3(u,v,w),add(u,v,cal(w)),add(v,u,cal(w)); dfs1(1,1); dfs2(1,1); for(re int i=1;i&lt;=n;i++) ans+=1ll*f1[i]*(f1[i]-1)+1ll*f2[i]*(f2[i]-1)+1ll*f1[i]*f2[i]*2; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"},{"name":"树形dp","slug":"树形dp","permalink":"andymo.top/tags/树形dp/"}]},{"title":"CF767C Garland","slug":"CF767C Garland","date":"2019-10-26T08:56:27.000Z","updated":"2019-10-26T10:43:46.118Z","comments":true,"path":"2019/10/26/CF767C Garland/","link":"","permalink":"andymo.top/2019/10/26/CF767C Garland/","excerpt":"","text":"树形dp 如果一个点的$sum==tot/3$并且它不是根，就计入答案，把它的$sum$清零 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 1000005int n,en,root,tot,ans1,ans2;int front[N],w[N],sum[N];bool used[N];struct edge&#123; int v,next;&#125;e[N&lt;&lt;1];il void add(int u,int v)&#123; en++; e[en].v=v; e[en].next=front[u]; front[u]=en;&#125;void dfs(int u,int fa)&#123; sum[u]=w[u]; for(re int i=front[u];i;i=e[i].next)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u); sum[u]+=sum[v]; &#125; if(sum[u]==tot/3)&#123; if(!ans1) ans1=u; else&#123; ans2=u; if(ans1!=root&amp;&amp;ans2!=root)&#123; printf(\"%d %d\",ans2,ans1); exit(0); &#125; &#125; sum[u]=0; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif int u; read(n); for(re int i=1;i&lt;=n;i++) &#123; in2(u,w[i]); if(u) add(u,i),add(i,u); else root=i; tot+=w[i]; &#125; if(tot%3)&#123; puts(\"-1\"); return 0; &#125; dfs(root,root); puts(\"-1\"); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"},{"name":"树形dp","slug":"树形dp","permalink":"andymo.top/tags/树形dp/"}]},{"title":"Poj 1655 树的重心","slug":"Poj 1655 树的重心","date":"2019-10-26T08:53:45.000Z","updated":"2019-10-26T10:53:04.060Z","comments":true,"path":"2019/10/26/Poj 1655 树的重心/","link":"","permalink":"andymo.top/2019/10/26/Poj 1655 树的重心/","excerpt":"","text":"树的重心： 定义1：找到一个点，其所有的子树中最大的子树节点数最少，那么这个点就是这棵树的重心。 定义2：以这个点为根，那么所有的子树（不算整个树自身）的大小都不超过整个树大小的一半。 性质1：树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么他们的距离和一样。 性质2：把两个树通过一条边相连得到一个新的树，那么新的树的重心在连接原来两个树的重心的路径上。 性质3：把一个树添加或删除一个叶子，那么它的重心最多只移动一条边的距离。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 20005int T,n,en;int front[N],dp[N],num[N];struct edge&#123; int v,next;&#125;e[N&lt;&lt;1];il void clear()&#123; memset(front,0,sizeof(front)); en=0;&#125;il void add(int u,int v)&#123; en++; e[en].v=v; e[en].next=front[u]; front[u]=en;&#125;void dfs(int u,int fa)&#123; dp[u]=0; num[u]=1; for(re int i=front[u];i;i=e[i].next)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u); num[u]+=num[v]; dp[u]=max(dp[u],num[v]); &#125; dp[u]=max(dp[u],n-num[u]);&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif int u,v; read(T); while(T--)&#123; read(n); clear(); for(re int i=1;i&lt;=n-1;i++)&#123; in2(u,v); add(u,v); add(v,u); &#125; dfs(1,1); int ans=inf,k; for(re int i=1;i&lt;=n;i++)&#123; if(dp[i]&lt;ans) ans=dp[i],k=i; &#125; printf(\"%d %d\\n\",k,ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"},{"name":"树形dp","slug":"树形dp","permalink":"andymo.top/tags/树形dp/"}]},{"title":"Luogu P3621 [APIO2007]风铃","slug":"Luogu P3621 [APIO2007]风铃","date":"2019-10-26T08:51:11.000Z","updated":"2019-10-26T10:47:31.814Z","comments":true,"path":"2019/10/26/Luogu P3621 [APIO2007]风铃/","link":"","permalink":"andymo.top/2019/10/26/Luogu P3621 [APIO2007]风铃/","excerpt":"","text":"对于每一个节点的左右子树，只有三种情况需要交换: 左边全是小深度的，右边全是大深度的 左边全是小深度的，右边大小深度都有 左边大小深度都有，右边全是大深度的 此时左右子树均为合法状态 深度差超过1或者左右子树都有大有小就无解 有大有小的状态深度一定是升序的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 100005int n,mn=inf,mx,ans;int l[N],r[N];void dfs(int u,int dep)&#123; if(u==-1)&#123; mn=min(mn,dep),mx=max(mx,dep); return; &#125; dfs(l[u],dep+1); dfs(r[u],dep+1);&#125;int solve(int u,int dep)&#123; //0为小深度，1为大深度，2为有大有小且升序 if(u==-1)&#123; if(dep==mn) return 0; return 1; &#125; int x=solve(l[u],dep+1),y=solve(r[u],dep+1); if((x==0&amp;&amp;y==1)||(x==0&amp;&amp;y==2)||(x==2&amp;&amp;y==1)) ans++; if(x==2||y==2)&#123; if(x==2&amp;&amp;y==2)&#123; puts(\"-1\"); exit(0); &#125; return 2; &#125; if(x+y==1) return 2;//小深度+大深度=有大有小 if(x+y==0) return 0;//都为小深度 if(x==1&amp;&amp;y==1) return 1;//都为大深度&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif read(n); for(re int i=1;i&lt;=n;i++) in2(l[i],r[i]); dfs(1,0); if(mx-mn&gt;1)&#123; puts(\"-1\"); return 0; &#125; if(mx==mn)&#123; puts(\"0\"); return 0; &#125; solve(1,0); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"},{"name":"树形dp","slug":"树形dp","permalink":"andymo.top/tags/树形dp/"}]},{"title":"Luogu P2016 战略游戏","slug":"Luogu P2016 战略游戏","date":"2019-10-26T08:45:16.000Z","updated":"2019-10-26T10:45:47.378Z","comments":true,"path":"2019/10/26/Luogu P2016 战略游戏/","link":"","permalink":"andymo.top/2019/10/26/Luogu P2016 战略游戏/","excerpt":"","text":"树形DP 这道题要控制的是边，不是点 $f[u][0]=\\sum f[v][1]$ $f[u][1]=\\sum min(f[v][0],f[v][1])$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 1505int n,en;int front[N],f[N][2];struct edge&#123; int v,next;&#125;e[N];il void add(int u,int v)&#123; en++; e[en].v=v; e[en].next=front[u]; front[u]=en;&#125;void dfs(int u)&#123; f[u][1]=1; for(re int i=front[u];i;i=e[i].next)&#123; int v=e[i].v; dfs(v); f[u][0]+=f[v][1]; f[u][1]+=min(f[v][0],f[v][1]); &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif int u,v,k; read(n); for(re int i=1;i&lt;=n;i++)&#123; in2(u,k); while(k--)&#123; read(v); add(u,v); &#125; &#125; dfs(0); printf(\"%d\",min(f[0][0],f[0][1])); return 0;&#125; 12345678910定义：对于图G=(V,E)来说,最小点覆盖指的是从V中取尽量少的点组成 一个集合,使得E中所有的边都与取出来的点相连.也就是说,设V&apos; 是图G的一个顶点覆盖,则对于图中的任意一条边(u,v),要么u属于 集合V&apos;,要么v属于集合V&apos;.在V&apos;中除去任何元素后V&apos;不在是顶点覆 盖，则V&apos;是极小顶点覆盖.称G的所有顶点覆盖中顶点个数最少的覆 盖为最小点覆盖。对于任意图G来说,这个问题不存在多项式时间的解法。不过对于树来说,却很容易。 目前有两种解法,一种基于贪心思想,另一种基于树形动态规划思想。","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"},{"name":"树形dp","slug":"树形dp","permalink":"andymo.top/tags/树形dp/"}]},{"title":"Luogu P1270 “访问”美术馆","slug":"Luogu P1270 “访问”美术馆","date":"2019-10-26T08:43:20.000Z","updated":"2019-10-26T10:44:49.424Z","comments":true,"path":"2019/10/26/Luogu P1270 “访问”美术馆/","link":"","permalink":"andymo.top/2019/10/26/Luogu P1270 “访问”美术馆/","excerpt":"","text":"记忆化搜索/树形dp 枚举分给左儿子的时间$i$,分给右儿子的时间就是$t-time[p]-i$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 1005int n,T;int time[N],pic[N],f[N][N];void dfs_read(int p)&#123; in2(time[p],pic[p]); time[p]&lt;&lt;=1; if(!pic[p]) dfs_read(p&lt;&lt;1),dfs_read(p&lt;&lt;1|1);&#125;int dfs(int p,int t)&#123; if(f[p][t]||!t) return f[p][t]; if(pic[p])&#123; return f[p][t]=min(pic[p],(t-time[p])/5); &#125; for(re int i=0;i&lt;=t-time[p];i++)&#123; f[p][t]=max(f[p][t],dfs(p&lt;&lt;1,i)+dfs(p&lt;&lt;1|1,t-time[p]-i)); &#125; return f[p][t];&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif read(T); T--; dfs_read(1); printf(\"%d\",dfs(1,T)); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"},{"name":"树形dp","slug":"树形dp","permalink":"andymo.top/tags/树形dp/"}]},{"title":"Luogu P3360 偷天换日","slug":"Luogu P3360 偷天换日","date":"2019-10-26T08:38:58.000Z","updated":"2019-10-26T10:46:33.915Z","comments":true,"path":"2019/10/26/Luogu P3360 偷天换日/","link":"","permalink":"andymo.top/2019/10/26/Luogu P3360 偷天换日/","excerpt":"","text":"树形dp+01背包 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 1005int T;int w[N],c[N],f[N][N];void dfs_read(int p)&#123; int time,k; in2(time,k); time&lt;&lt;=1; if(!k)&#123; dfs_read(p&lt;&lt;1),dfs_read(p&lt;&lt;1|1); for(re int i=time;i&lt;=T;i++) for(re int j=0;j&lt;=i-time;j++) f[p][i]=max(f[p][i],f[p&lt;&lt;1][j]+f[p&lt;&lt;1|1][i-time-j]); &#125; else&#123; for(re int i=1;i&lt;=k;i++)&#123; in2(w[i],c[i]); for(re int j=T;j&gt;=c[i]+time;j--)&#123; f[p][j]=max(f[p][j],f[p][j-c[i]]+w[i]); &#125; &#125; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif read(T); T--; dfs_read(1); printf(\"%d\",f[1][T]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"},{"name":"树形dp","slug":"树形dp","permalink":"andymo.top/tags/树形dp/"},{"name":"背包","slug":"背包","permalink":"andymo.top/tags/背包/"}]},{"title":"Luogu P1273 有线电视网","slug":"Luogu P1273 有线电视网","date":"2019-10-26T08:35:48.000Z","updated":"2019-10-26T09:55:45.811Z","comments":true,"path":"2019/10/26/Luogu P1273 有线电视网/","link":"","permalink":"andymo.top/2019/10/26/Luogu P1273 有线电视网/","excerpt":"","text":"12345678910111213f(u,t,j):以u为根的子树,考虑根及前t个子树,选j个叶结点(用户终端)最多能赚多少钱(有可能正有可能负) 则有如下状态转移方程： 1.若u为叶子结点，则f(u,?,1)=v[u];2.若u非叶子结点，则有： f(u,?,0) = 0; f(u,t,j) = max &#123; f(u,t-1,j) , max&#123; f(u,t-1,j-k) + f(v,son(v)_size,k) - W(u,v) &#125; &#125; 0&lt;t&lt;=son(u)_size1&lt;=j&lt;=m(v1) + m(v2) + ... + m(vt) , m(v)表示以v为根的子树的叶结点数,v1...vt是u的前t个子结点 1&lt;=k&lt;=min&#123; m(vt) , j &#125;对于每棵子树,这其实就是个分组背包的模型。我们可以把每个以u为根的子树的每个子树看为一个分组,每个分组至多选一种物品，如第k种物品：体积是k,价值是f(v,son(v)_size,k)-W(u,v)。这里再解释下分组的每种物品，分组背包中各组的物品互斥即只能选一个。显然，根据我们对f(u,t,j)的定义,如f(u,t,k1)和f(u,t,k2)就是两种互斥的物品，因为不可能说我即转播了k1个用户又转播了k2个用户。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 3005int n,m,en,tot;int a[N],front[N],f[N][N],son[N];struct edge&#123; int v,w,next;&#125;e[N];il void add(int u,int v,int w)&#123; en++; e[en].v=v; e[en].w=w; e[en].next=front[u]; front[u]=en;&#125;int dfs(int u)&#123; if(!front[u])&#123; f[u][1]=a[u]; return 1; &#125; int mu=0,mv; for(re int i=front[u];i;i=e[i].next)&#123; int v=e[i].v,w=e[i].w; mv=dfs(v); mu+=mv; for(re int j=min(mu,m);j&gt;0;j--)&#123;到当前儿子选了共j个节点 for(re int k=1;k&lt;=min(mv,j);k++)&#123;在当前儿子中选k个节点 f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]-w); &#125; &#125; &#125; return mu;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen(\"data.in\",\"r\",stdin);#endif int k,v,w; in2(n,m); for(re int i=1;i&lt;=n-m;i++)&#123; read(k); while(k--)&#123; in2(v,w); add(i,v,w); &#125; &#125; for(re int i=n-m+1;i&lt;=n;i++) read(a[i]); for(re int i=1;i&lt;=n;i++) for(re int j=1;j&lt;=m;j++) f[i][j]=-inf; dfs(1); for(re int i=m;i&gt;=0;i--)&#123; if(f[1][i]&gt;=0)&#123; printf(\"%d\",i); break; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"},{"name":"树形dp","slug":"树形dp","permalink":"andymo.top/tags/树形dp/"}]},{"title":"Luogu P1268 树的重量","slug":"Luogu P1268 树的重量","date":"2019-09-14T08:16:36.000Z","updated":"2019-10-26T09:54:49.468Z","comments":true,"path":"2019/09/14/Luogu P1268 树的重量/","link":"","permalink":"andymo.top/2019/09/14/Luogu P1268 树的重量/","excerpt":"","text":"$n=1$ 答案为 $0$ $n=2$ 答案为 $dis(1,2)$ $n=3$ 如图 设蓝色部分长度为 $len$，答案为 $dis(1,2) + len$, $len = (dis(1,3)+dis(2,3)-dis(1,2))/2$ $n&gt;3$ 同理。枚举$i$，可以认为当前点是从点1~i​的路径上分叉出来的，求出的最小 $ len $ 就是要加到答案里面去的。如图 大概是个容斥原理 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 35int n;int a[N][N];int main()&#123; read(n); while(n)&#123; for(re int i=1;i&lt;=n-1;i++)&#123; for(re int j=i+1;j&lt;=n;j++)&#123; read(a[i][j]); &#125; &#125; int ans=a[1][2]; //i为当前点，j为枚举的1~j的路径，i从1~j的路径分叉出来 for(re int i=3;i&lt;=n;i++)&#123; int res=inf; for(re int j=2;j&lt;i;j++)&#123; res=min(res,(a[1][i]+a[j][i]-a[1][j])/2); //即1到当前点的距离+路径终点到当前点的距离-路径长度再除以2 //拿n=4的图模拟一下 &#125; ans+=res; &#125; printf(\"%d\\n\",ans); read(n); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"构造","slug":"构造","permalink":"andymo.top/tags/构造/"}]},{"title":"51nod 2636 卡车加油","slug":"51nod 2636 卡车加油","date":"2019-09-14T07:18:57.000Z","updated":"2019-10-26T09:50:45.841Z","comments":true,"path":"2019/09/14/51nod 2636 卡车加油/","link":"","permalink":"andymo.top/2019/09/14/51nod 2636 卡车加油/","excerpt":"","text":"贪心把能走过的点的油量扔进优先队列，每次取最大的加油，如果队列为空还不能到达就-1最后再看能不能到 $l$，同理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 10005int d,p,n;struct node&#123; int a,b; bool operator &lt; (const node &amp;rhs) const&#123; return a&lt;rhs.a; &#125;&#125;a[N];priority_queue &lt;int&gt; q;int main()&#123; in3(d,p,n); for(re int i=1;i&lt;=n;i++) in2(a[i].a,a[i].b); sort(a+1,a+n+1); int now=p,ans=0; for(re int i=1;i&lt;=n;i++)&#123; while(now&lt;a[i].a&amp;&amp;!q.empty())&#123; now+=q.top(); q.pop(); ans++; &#125; if(now&lt;a[i].a)&#123; puts(\"-1\"); return 0; &#125; q.push(a[i].b); &#125; while(now&lt;d&amp;&amp;!q.empty())&#123; now+=q.top(); q.pop(); ans++; &#125; if(now&lt;d)&#123; puts(\"-1\"); return 0; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"andymo.top/tags/贪心/"}]},{"title":"Luogu P3950 部落冲突","slug":"Luogu P3950 部落冲突","date":"2019-09-08T08:49:55.000Z","updated":"2019-10-26T10:47:00.802Z","comments":true,"path":"2019/09/08/Luogu P3950 部落冲突/","link":"","permalink":"andymo.top/2019/09/08/Luogu P3950 部落冲突/","excerpt":"","text":"树剖 边权转点权，每次开战深度较深的点点权++ 查询时查路径权值和减掉深度浅的那个点的权值（深度浅的点如果开战，它向上的道路就不能走，但不影响答案） 不会写边权的树剖，也懒得写区间修改 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 300005#define ls p&lt;&lt;1#define rs p&lt;&lt;1|1int n,m,en,cnt,tot;int front[N],fa[N],dep[N],size[N],top[N],id[N],son[N],war[N],tree[N&lt;&lt;2];struct edge&#123; int v,next;&#125;e[N&lt;&lt;1];il void addedge(int u,int v)&#123; en++; e[en].v=v; e[en].next=front[u]; front[u]=en;&#125;void dfs1(int u,int f)&#123; dep[u]=dep[f]+1; fa[u]=f; size[u]=1; int maxson=-1; for(re int i=front[u];i;i=e[i].next)&#123; int v=e[i].v; if(v==f) continue; dfs1(v,u); size[u]+=size[v]; if(maxson&lt;size[v]) maxson=size[v],son[u]=v; &#125;&#125;void dfs2(int u,int topf)&#123; id[u]=++cnt; top[u]=topf; if(!son[u]) return; dfs2(son[u],topf); for(re int i=front[u];i;i=e[i].next)&#123; int v=e[i].v; if(v==fa[u]||v==son[u]) continue; dfs2(v,v); &#125;&#125;il void up(int p)&#123; tree[p]=tree[ls]+tree[rs];&#125;void add(int p,int l,int r,int pos,int val)&#123; if(l==r)&#123; tree[p]=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) add(ls,l,mid,pos,val); else add(rs,mid+1,r,pos,val); up(p);&#125;int query(int p,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr)&#123; return tree[p]; &#125; int mid=(l+r)&gt;&gt;1,res=0; if(ql&lt;=mid) res+=query(ls,l,mid,ql,qr); if(qr&gt;mid) res+=query(rs,mid+1,r,ql,qr); return res;&#125;il bool qrange(int x,int y)&#123; int res=0; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res+=query(1,1,n,id[top[x]],id[x]); x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y]) swap(x,y); res+=query(1,1,n,id[x],id[y])-query(1,1,n,id[x],id[x]); return res==0;&#125;int main()&#123; int u,v,x; char ch; in2(n,m); for(re int i=1;i&lt;=n-1;i++) in2(u,v),addedge(u,v),addedge(v,u); dfs1(1,0); dfs2(1,0); while(m--)&#123; scanf(\" %c\",&amp;ch); if(ch=='Q')&#123; in2(u,v); if(qrange(u,v)) puts(\"Yes\"); else puts(\"No\"); &#125; else if(ch=='C')&#123; in2(u,v); if(dep[u]&gt;dep[v]) swap(u,v); war[++tot]=v; add(1,1,n,id[v],1); &#125; else&#123; read(x); add(1,1,n,id[war[x]],0); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"andymo.top/tags/数据结构/"},{"name":"树链剖分","slug":"树链剖分","permalink":"andymo.top/tags/树链剖分/"}]},{"title":"CF1207D","slug":"CF1207D","date":"2019-08-29T14:00:44.000Z","updated":"2019-10-26T09:54:24.527Z","comments":true,"path":"2019/08/29/CF1207D/","link":"","permalink":"andymo.top/2019/08/29/CF1207D/","excerpt":"","text":"计数题大概吧 考虑有多少个递增的排列，用总排列去减 求x有多少个递增序列，计答案为$cnt$, 则 $ cnt=c1!c2!…*cn! $ , $ cx $ 是 $ x $ 这个数出现的次数 y同理 假设$ （x , y） $,$ x,y $同时递增。那么$x$递增的情况和$y$递增的情况是等价的，要减去重复的，即减去相同二元组的情况。 用map计算相同二元组的个数至今不会用迭代器 记得sort 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 1e18 #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 300005#define mod 998244353int n;pair &lt;int,int&gt; a[N];map &lt;pair&lt;int,int&gt;,int&gt; mp;ll f[N];bool cmp(pair&lt;int,int&gt; a,pair&lt;int,int&gt; b)&#123; if(a.first==b.first) return a.second&lt;b.second; return a.first&lt;b.first;&#125;//大概是这么排吧ll cal()&#123; int l=1; ll res=1; while(l&lt;=n)&#123; int r=l+1; while(r&lt;=n&amp;&amp;a[l].first==a[r].first) r++; res=res*f[r-l]%mod; l=r; &#125; return res;&#125;int main()&#123; read(n); for(re int i=1;i&lt;=n;i++) in2(a[i].first,a[i].second); f[0]=1; for(re int i=1;i&lt;=n;i++) f[i]=f[i-1]*i%mod; ll ans=f[n]; sort(a+1,a+n+1,cmp); ans=((ans-cal())%mod+mod)%mod; for(re int i=1;i&lt;=n;i++) swap(a[i].first,a[i].second); sort(a+1,a+n+1,cmp); ans=((ans-cal())%mod+mod)%mod; for(re int i=1;i&lt;=n;i++) swap(a[i].first,a[i].second); sort(a+1,a+n+1,cmp); bool flag=1; for(re int i=2;i&lt;=n;i++)&#123; if(a[i].second&lt;a[i-1].second)&#123; flag=0; break; &#125; &#125; if(flag)&#123; for(re int i=1;i&lt;=n;i++) mp[a[i]]++; ll res=1; map&lt;pair&lt;int,int&gt;,int&gt;::iterator it; for(it=mp.begin();it!=mp.end();it++)&#123; res=res*f[it-&gt;second]%mod; &#125; ans=((ans+res)%mod+mod)%mod; &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"计数","slug":"计数","permalink":"andymo.top/tags/计数/"}]},{"title":"CF1207C","slug":"CF1207C","date":"2019-08-28T03:33:25.000Z","updated":"2019-10-26T10:24:55.307Z","comments":true,"path":"2019/08/28/CF1207C/","link":"","permalink":"andymo.top/2019/08/28/CF1207C/","excerpt":"","text":"题目链接 DP 分搭一层和搭两层来讨论 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 1e18 #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 200005int t;int n,a,b;ll f[N][3];char s[N];int main()&#123; read(t); while(t--)&#123; in3(n,a,b); scanf(\" %s\",s); for(re int i=0;i&lt;=n;i++) f[i][1]=f[i][2]=inf;//初始化 f[0][1]=b;//第一个只能一层 for(re int i=1;i&lt;=n;i++)&#123; if(s[i-1]=='1') f[i][2]=f[i-1][2]+2ll*b+a; else&#123; f[i][1]=min(f[i-1][1]+b+a,f[i-1][2]+b+2ll*a); f[i][2]=min(f[i-1][1]+2ll*b+2ll*a,f[i-1][2]+2ll*b+a); &#125; &#125; printf(\"%lld\\n\",f[n][1]);//最后一个只能一层 &#125; return 0;&#125; 贪心感觉不太好写","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"}]},{"title":"Luogu P1650 田忌赛马","slug":"Luogu P1650 田忌赛马","date":"2019-08-27T03:09:53.000Z","updated":"2019-10-26T09:56:37.972Z","comments":true,"path":"2019/08/27/Luogu P1650 田忌赛马/","link":"","permalink":"andymo.top/2019/08/27/Luogu P1650 田忌赛马/","excerpt":"","text":"贪心或DP 贪心思路见P2587 [ZJOI2008]泡泡堂 大概是双倍经验 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 100005int n;int a[N],b[N];int main()&#123; read(n); for(re int i=1;i&lt;=n;i++) read(a[i]); sort(a+1,a+n+1); for(re int i=1;i&lt;=n;i++) read(b[i]); sort(b+1,b+n+1); int s=1,t=n,l=1,r=n,ans=0; while(s&lt;=t&amp;&amp;l&lt;=r)&#123; if(a[s]&gt;b[l]) ans+=200,s++,l++; else if(a[t]&gt;b[r]) ans+=200,t--,r--; else ans-=(a[s]&lt;b[r])*200,s++,r--; &#125; printf(\"%d\",ans); return 0;&#125; DP 设$f[i][j]$表示齐王按从强到弱的顺序出马和田忌进行了$i$场比赛之后，从头取了$j$匹较强的马，从尾取了$i-j$匹较弱的马，所能获得的最大盈利。 则状态转移方程为:$f[i][j]=max(f[i-1][j]+g[n-(i-j)+1][i],f[i-1][j-1]+g[j][i])$其中$g[i][j]$表示田忌的马和齐王的马分别按照由强到弱的顺序排序之后，田忌的第 $i$ 匹马和齐王的第 $j$ 匹马赛跑所能取得的盈利,胜为 200, 负为 -200 ,平为 0。 图解： 转自tby的博客 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 2005int n;int a[N],b[N],f[N][N],g[N][N];bool cmp(int x,int y)&#123; return x&gt;y;&#125;int main()&#123; read(n); for(re int i=1;i&lt;=n;i++) read(a[i]); sort(a+1,a+n+1,cmp); for(re int i=1;i&lt;=n;i++) read(b[i]); sort(b+1,b+n+1,cmp); for(re int i=1;i&lt;=n;i++)&#123; for(re int j=1;j&lt;=n;j++)&#123; if(a[i]&gt;b[j]) g[i][j]=200; else if(a[i]==b[j]) g[i][j]=0; else g[i][j]=-200; f[i][j]=-inf; //数值可能为负 &#125; &#125; for(re int i=1;i&lt;=n;i++)&#123; f[i][0]=f[i-1][0]+g[n-i+1][i]; f[i][i]=f[i-1][i-1]+g[i][i]; //j=0或i时特殊处理 for(re int j=1;j&lt;i;j++) f[i][j]=max(f[i-1][j]+g[n-i+j+1][i],f[i-1][j-1]+g[j][i]); &#125; int ans=f[n][1]; for(re int i=2;i&lt;=n;i++) ans=max(ans,f[n][i]); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"andymo.top/tags/贪心/"}]},{"title":"Luogu P2587 [ZJOI2008]泡泡堂","slug":"Luogu P2587 [ZJOI2008]泡泡堂","date":"2019-08-27T02:38:46.000Z","updated":"2019-10-26T09:58:32.280Z","comments":true,"path":"2019/08/27/Luogu P2587 [ZJOI2008]泡泡堂/","link":"","permalink":"andymo.top/2019/08/27/Luogu P2587 [ZJOI2008]泡泡堂/","excerpt":"","text":"神仙贪心 田忌赛马的策略会gg 1.判断我方最菜能否胜对方最菜，不能就跳2（用最菜虐对方最菜和用更犇的去虐价值都是2） 2.判断我方最犇能否胜对方最犇，不能就跳3（虐得过就没必要送人头） 3.判断我方最菜和对方最犇是否平手（平手总比白送强） 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 100005int n;int a[N],b[N];int main()&#123; read(n); for(re int i=1;i&lt;=n;i++) read(a[i]); sort(a+1,a+n+1); for(re int i=1;i&lt;=n;i++) read(b[i]); sort(b+1,b+n+1); int s=1,t=n,l=1,r=n,ans=0; while(s&lt;=t&amp;&amp;l&lt;=r)&#123; if(a[s]&gt;b[l]) ans+=2,s++,l++; else if(a[t]&gt;b[r]) ans+=2,t--,r--; else ans+=a[s]==b[r],s++,r--; &#125; printf(\"%d \",ans); swap(a,b); s=l=1,t=r=n,ans=0; while(s&lt;=t&amp;&amp;l&lt;=r)&#123; if(a[s]&gt;b[l]) ans+=2,s++,l++; else if(a[t]&gt;b[r]) ans+=2,t--,r--; else ans+=a[s]==b[r],s++,r--; &#125; printf(\"%d\",n*2-ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"andymo.top/tags/贪心/"}]},{"title":"牛客NOIP暑期七天营-普及组5 B","slug":"牛客NOIP暑期七天营-普及组5-B","date":"2019-08-24T14:08:07.000Z","updated":"2019-10-26T10:56:00.727Z","comments":true,"path":"2019/08/24/牛客NOIP暑期七天营-普及组5-B/","link":"","permalink":"andymo.top/2019/08/24/牛客NOIP暑期七天营-普及组5-B/","excerpt":"","text":"树形dp 1，2，3分别代表三种颜色 f[u][1]+=max(f[v][2],f[v][3]) f[u][2]+=max(f[v][1],f[v][3]) f[u][3]+=max(f[v][1],f[v][2])大概是道板子题 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 100005int n,en;int front[N],x[N],y[N],z[N];ll f[N][4];struct edge&#123; int v,next;&#125;e[N&lt;&lt;1];il void add(int u,int v)&#123; en++; e[en].v=v; e[en].next=front[u]; front[u]=en;&#125;void dfs(int u,int fa)&#123; f[u][1]=x[u]; f[u][2]=y[u]; f[u][3]=z[u]; for(re int i=front[u];i;i=e[i].next)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u); f[u][1]+=max(f[v][2],f[v][3]); f[u][2]+=max(f[v][1],f[v][3]); f[u][3]+=max(f[v][1],f[v][2]); &#125;&#125;int main()&#123; int u,v; read(n); for(re int i=1;i&lt;=n-1;i++) in2(u,v),add(u,v),add(v,u); for(re int i=1;i&lt;=n;i++) in3(x[i],y[i],z[i]); dfs(1,1); printf(\"%lld\",max(f[1][1],max(f[1][2],f[1][3]))); return 0;&#125;","categories":[],"tags":[{"name":"dp","slug":"dp","permalink":"andymo.top/tags/dp/"},{"name":"树形dp","slug":"树形dp","permalink":"andymo.top/tags/树形dp/"}]},{"title":"牛客NOIP暑期七天营-普及组5 A","slug":"牛客NOIP暑期七天营-普及组5 A","date":"2019-08-24T13:33:09.000Z","updated":"2019-10-26T10:55:05.931Z","comments":true,"path":"2019/08/24/牛客NOIP暑期七天营-普及组5 A/","link":"","permalink":"andymo.top/2019/08/24/牛客NOIP暑期七天营-普及组5 A/","excerpt":"","text":"自己瞎搞的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 100005int n;ll a[N],s[N];int main()&#123; ll sum=0; read(n); for(re int i=1;i&lt;=n;i++)&#123; readl(a[i]); sum+=a[i]*i; &#125; for(re int i=n;i&gt;=1;i--) s[i]=s[i+1]+a[i]; ll ans=sum,l=0,r=sum; for(re int i=1;i&lt;=n;i++)&#123; l+=a[i]*i; r-=s[i]; ans=min(ans,l+r); &#125; printf(\"%lld\",ans); return 0;&#125; 还搞了个后缀… 正解： 第一部分的数组为$ 1a[1]+2a[2]+..+k*a[k] $,可处理前缀和。 第二部分的数组为$ (i-k+1)a[i]+(i-k+2)a[i+1]+…+(n-k)a[n] $，提取出$ -k(a[i]+a[i+1]+…a[n]) $，发现和上面相同，都是下标乘以数组元素的前缀和。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 100005int n;ll a[N],s[N],sum[N];int main()&#123; read(n); for(re int i=1;i&lt;=n;i++)&#123; readl(a[i]); s[i]=s[i-1]+a[i]; sum[i]=sum[i-1]+a[i]*i; &#125; ll ans=sum[n]; for(re int i=1;i&lt;=n;i++)&#123; ans=min(ans,sum[n]-(s[n]-s[i])*i); &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"andymo.top/tags/模拟/"}]},{"title":"New Post","slug":"newpost","date":"2019-08-23T07:37:47.000Z","updated":"2019-08-23T07:45:59.972Z","comments":true,"path":"2019/08/23/newpost/","link":"","permalink":"andymo.top/2019/08/23/newpost/","excerpt":"","text":"My New Blog!","categories":[],"tags":[]},{"title":"牛客NOIP暑期七天营-普及组4 C","slug":"牛客NOIP暑期七天营-普及组4 C","date":"2019-08-23T07:37:47.000Z","updated":"2019-10-26T10:53:38.390Z","comments":true,"path":"2019/08/23/牛客NOIP暑期七天营-普及组4 C/","link":"","permalink":"andymo.top/2019/08/23/牛客NOIP暑期七天营-普及组4 C/","excerpt":"","text":"反正我输出无解24分 贪心 判断是否可行： 任意两点（已知的点）曼哈顿距离*d &gt;= 两点价值之差的绝对值 ​ 丢进小根堆，价值小的先 每次取堆顶，四向扩展，标记，可保证正确性 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;)&#123;if(c==&apos;-&apos;)f=-f;c=getchar();&#125; while(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)&#123;x=x*10+c-&apos;0&apos;;c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;)&#123;if(c==&apos;-&apos;)f=-f;c=getchar();&#125; while(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)&#123;x=x*10+c-&apos;0&apos;;c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 2005int h,w,n,d;const int dir[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;const int mod=1e9+7;struct node&#123; int x,y,c; bool operator &lt;(const node &amp;rhs) const&#123; return c&gt;rhs.c; &#125;&#125;a[N];int dis(int i,int j)&#123; return abs(a[i].x-a[j].x)+abs(a[i].y-a[j].y);&#125; ll map[N][N];bool vis[N][N];priority_queue &lt;node&gt; q;int main()&#123; in4(h,w,n,d); for(re int i=1;i&lt;=n;i++) in3(a[i].x,a[i].y,a[i].c); for(re int i=1;i&lt;=n;i++)&#123; for(re int j=i+1;j&lt;=n;j++)&#123; if(dis(i,j)*d&lt;abs(a[i].c-a[j].c))&#123; puts(&quot;PitayaCrying&quot;); return 0; &#125; &#125; &#125; for(re int i=1;i&lt;=n;i++) q.push(a[i]); while(!q.empty())&#123; node now=q.top(); q.pop(); if(vis[now.x][now.y]) continue; vis[now.x][now.y]=1; map[now.x][now.y]=now.c; for(re int i=0;i&lt;4;i++)&#123; int nx=now.x+dir[i][0],ny=now.y+dir[i][1]; if(nx&lt;1||nx&gt;h||ny&lt;1||ny&gt;w||vis[nx][ny]) continue; q.push((node)&#123;nx,ny,now.c+d&#125;); &#125; &#125; ll ans=0; for(re int i=1;i&lt;=h;i++)&#123; for(re int j=1;j&lt;=w;j++)&#123; ans=(ans+map[i][j])%mod; &#125; &#125; printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"andymo.top/tags/贪心/"},{"name":"数据结构","slug":"数据结构","permalink":"andymo.top/tags/数据结构/"},{"name":"堆","slug":"堆","permalink":"andymo.top/tags/堆/"}]},{"title":"牛客NOIP暑期七天营-普及组4 D","slug":"牛客NOIP暑期七天营-普及组4 D","date":"2019-08-23T07:37:47.000Z","updated":"2019-10-26T10:54:28.050Z","comments":true,"path":"2019/08/23/牛客NOIP暑期七天营-普及组4 D/","link":"","permalink":"andymo.top/2019/08/23/牛客NOIP暑期七天营-普及组4 D/","excerpt":"","text":"不差分前缀和70，部分分也太多了8 差分 模拟 每个三角形的每一行的首尾打上差分标记 时间复杂度 $ O(1e8) $ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;namespace io&#123; #define re register #define ll long long #define inf 0x3f3f3f3f #define il inline #define in1(a) read(a) #define in2(a,b) in1(a),in1(b) #define in3(a,b,c) in2(a,b),in1(c) #define in4(a,b,c,d) in2(a,b),in2(c,d) il void readl(ll &amp;x)&#123; x=0;ll f=1;char c=getchar(); while(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;)&#123;if(c==&apos;-&apos;)f=-f;c=getchar();&#125; while(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)&#123;x=x*10+c-&apos;0&apos;;c=getchar();&#125; x*=f; &#125; il void read(int &amp;x)&#123; x=0;int f=1;char c=getchar(); while(c&lt;&apos;0&apos;||c&gt;&apos;9&apos;)&#123;if(c==&apos;-&apos;)f=-f;c=getchar();&#125; while(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)&#123;x=x*10+c-&apos;0&apos;;c=getchar();&#125; x*=f; &#125;&#125;using namespace io;#define N 1005int n;ll map[N][N];int main()&#123; int opt,x,y,l,c; read(n); while(n--)&#123; read(opt); in4(x,y,l,c); if(opt==1)&#123; for(re int i=0;i&lt;=l;i++)&#123; map[x+i][y]+=c; map[x+i][y+l+1-i]-=c; &#125; &#125; else if(opt==2)&#123; for(re int i=0;i&lt;=l;i++)&#123; map[x+i][y-l+i]+=c; map[x+i][y+1]-=c; &#125; &#125; else if(opt==3)&#123; for(re int i=0;i&lt;=l;i++)&#123; map[x-i][y]+=c; map[x-i][y+l+1-i]-=c; &#125; &#125; else&#123; for(re int i=0;i&lt;=l;i++)&#123; map[x-i][y-l+i]+=c; map[x-i][y+1]-=c; &#125; &#125; &#125; ll ans=-1e17; for(re int i=1;i&lt;=1000;i++)&#123; for(re int j=1;j&lt;=1000;j++)&#123; map[i][j]+=map[i][j-1]; ans=max(ans,map[i][j]); &#125; &#125; printf(&quot;%lld&quot;,ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"andymo.top/categories/题解/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"andymo.top/tags/模拟/"},{"name":"差分","slug":"差分","permalink":"andymo.top/tags/差分/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-23T02:48:22.230Z","updated":"2019-08-23T06:00:11.767Z","comments":true,"path":"2019/08/23/hello-world/","link":"","permalink":"andymo.top/2019/08/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new postpost1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}